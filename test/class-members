#!/usr/bin/env python3.8


from functools import cached_property
from pprint import pprint
from typing import Optional, Tuple

from art_of_geom._util._inspect import describe


class C:
    DEFAULT_X = 0

    @staticmethod
    def print(x) -> None:
        print(x)

    @classmethod
    def default_x(cls) -> int:
        return cls.DEFAULT_X

    def __init__(self, x: Optional[int] = None, /) -> None:
        self._x = \
            self.DEFAULT_X \
            if x is None \
            else x

    @property
    def x(self) -> int:
        return self._x

    @x.setter
    def x(self, x: int) -> None:
        self._x = x

    @x.deleter
    def x(self) -> None:
        self._x = self.DEFAULT_X

    @cached_property
    def cached_default_x(self):
        return self.DEFAULT_X

    def print_x(self):
        print(self._x)

    def __lt__(self, other: int) -> bool:
        return self._x < other

    def __le__(self, other: int) -> bool:
        return self._x <= other

    def __eq__(self, other: int) -> bool:
        return self._x == other

    def __ne__(self, other: int) -> bool:
        return self._x != other

    def __ge__(self, other: int) -> bool:
        return self._x >= other

    def __gt__(self, other: int) -> bool:
        return self._x > other

    def __abs__(self) -> int:
        return abs(self._x)

    def __neg__(self) -> int:
        return -self._x

    def __add__(self, other: int) -> int:
        return self._x + other

    def __radd__(self, other: int) -> int:
        return other + self._x

    def __sub__(self, other: int) -> int:
        return self._x - other

    def __rsub__(self, other: int) -> int:
        return other - self._x

    def __mul__(self, other: int) -> int:
        return self._x * other

    def __rmul__(self, other: int) -> int:
        return other * self._x

    def __truediv__(self, other: int) -> float:
        return self._x / other

    def __rtruediv__(self, other: int) -> float:
        return other / self._x

    def __floordiv__(self, other: int) -> int:
        return self._x // other

    def __rfloordiv__(self, other: int) -> int:
        return other // self._x

    def __mod__(self, other: int) -> int:
        return self._x % other

    def __rmod__(self, other: int) -> int:
        return other % self._x

    def __divmod__(self, other: int) -> Tuple[int, int]:
        return divmod(self._x, other)

    def __rdivmod__(self, other: int) -> Tuple[int, int]:
        return divmod(other, self._x)


print(C.print); pprint(describe(C.print), sort_dicts=False); print()

print(C.default_x); pprint(describe(C.default_x), sort_dicts=False); print()

print(C.x); pprint(describe(C.x), sort_dicts=False); print()

print(C.cached_default_x); pprint(describe(C.cached_default_x), sort_dicts=False); print()

pprint(C.print_x); pprint(describe(C.print_x), sort_dicts=False); print()

for op in ('__lt__', '__le__', '__eq__', '__ne__', '__ge__', '__gt__',
           '__abs__', '__neg__', '__add__', '__radd__', '__sub__', '__rsub__',
           '__mul__', '__rmul__', '__truediv__', '__rtruediv__',
           '__floordiv__', '__rfloordiv__', '__mod__', '__rmod__', '__divmod__', '__rdivmod__'):
    print(method := getattr(C, op)); pprint(describe(method), sort_dicts=False); print()
